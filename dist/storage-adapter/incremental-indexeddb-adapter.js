var $=Object.defineProperty;var d=(r,t)=>$(r,"name",{value:t,configurable:!0});var f=typeof window!="undefined"&&!!window.__loki_incremental_idb_debug,E=class{constructor(t){this.mode="incremental";if(this.mode="incremental",this.options=t||{},this.chunkSize=100,this.megachunkCount=this.options.megachunkCount||24,this.lazyCollections=this.options.lazyCollections||[],this.idb=null,this._prevLokiVersionId=null,this._prevCollectionVersionIds={},!(this.megachunkCount>=4&&this.megachunkCount%2===0))throw new Error("megachunkCount must be >=4 and divisible by 2")}_getChunk(t,n){let o=n*this.chunkSize,i=o+this.chunkSize-1;t.ensureId();let e=t.idIndex,s=null,l=e.length-1,a=0,m;for(;e[a]<e[l];)m=a+l>>1,e[m]<o?a=m+1:l=m;if(l===a&&e[a]>=o&&e[a]<=i&&(s=a),s===null)return[];let c=null;for(let g=s+this.chunkSize-1;g>=s;g--)if(e[g]<=i){c=g;break}let k=t.data[s];if(!(k&&k.$loki>=o&&k.$loki<=i))throw new Error("broken invariant firstelement");let h=t.data[c];if(!(h&&h.$loki>=o&&h.$loki<=i))throw new Error("broken invariant lastElement");let u=t.data.slice(s,c+1);if(u.length>this.chunkSize)throw new Error("broken invariant - chunk size");return u}saveDatabase(t,n,o){let i=this;if(!this.idb){this._initializeIDB(t,o,()=>{i.saveDatabase(t,n,o)});return}if(this.operationInProgress)throw new Error("Error while saving to database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,f&&console.log("saveDatabase - begin"),f&&console.time("saveDatabase");function e(s){f&&s&&console.error(s),f&&console.timeEnd("saveDatabase"),i.operationInProgress=!1,o(s)}d(e,"finish");try{let s=d(()=>{console.error("Unexpected successful tx - cannot update previous version ids")},"updatePrevVersionIds"),l=!1,a=this.idb.transaction(["LokiIncrementalData"],"readwrite");a.oncomplete=()=>{s(),e(),l&&i.options.onDidOverwrite&&i.options.onDidOverwrite()},a.onerror=u=>{e(u)},a.onabort=u=>{e(u)};let m=a.objectStore("LokiIncrementalData"),c=d(u=>{try{let g=!u,p=i._putInChunks(m,n(),g,u);s=d(()=>{i._prevLokiVersionId=p.lokiVersionId,p.collectionVersionIds.forEach(({name:I,versionId:b})=>{i._prevCollectionVersionIds[I]=b})},"updatePrevVersionIds"),a.commit&&a.commit()}catch(g){console.error("idb performSave failed: ",g),a.abort()}},"performSave"),k=d(()=>{w(m.getAllKeys(),({target:u})=>{let g=B(u.result);c(g)},u=>{console.error("Getting all keys failed: ",u),a.abort()})},"getAllKeysThenSave");d(()=>{w(m.get("loki"),({target:u})=>{N(u.result)===i._prevLokiVersionId?c():(f&&console.warn("Another writer changed Loki IDB, using slow path..."),l=!0,k())},u=>{console.error("Getting loki chunk failed: ",u),a.abort()})},"getLokiThenSave")()}catch(s){e(s)}}_putInChunks(t,n,o,i){let e=this,s=[],l=0,a=d((c,k)=>{let h=new Set;o&&c.dirtyIds.forEach(g=>{let p=g/e.chunkSize|0;h.add(p)}),c.dirtyIds=[];let u=d(g=>{let p=e._getChunk(c,g);e.options.serializeChunk&&(p=e.options.serializeChunk(c.name,p)),p=JSON.stringify(p),l+=p.length,f&&o&&console.log(`Saving: ${c.name}.chunk.${g}`),t.put({key:`${c.name}.chunk.${g}`,value:p})},"prepareChunk");if(o)h.forEach(u);else{let g=c.maxId/e.chunkSize|0;for(let I=0;I<=g;I+=1)u(I);let p=i[c.name]||0;for(let I=g+1;I<=p;I+=1){let b=`${c.name}.chunk.${I}`;t.delete(b),f&&console.warn(`Deleted chunk: ${b}`)}}if(c.dirty||h.size||!o){c.idIndex=[],c.data=[],c.idbVersionId=V(),s.push({name:c.name,versionId:c.idbVersionId});let g=JSON.stringify(c);l+=g.length,f&&o&&console.log(`Saving: ${c.name}.metadata`),t.put({key:`${c.name}.metadata`,value:g})}n.collections[k]={name:c.name}},"prepareCollection");n.collections.forEach(a),n.idbVersionId=V();let m=JSON.stringify(n);return l+=m.length,f&&o&&console.log("Saving: loki"),t.put({key:"loki",value:m}),f&&console.log(`saved size: ${l}`),{lokiVersionId:n.idbVersionId,collectionVersionIds:s}}loadDatabase(t,n){let o=this;if(this.operationInProgress)throw new Error("Error while loading database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,f&&console.log("loadDatabase - begin"),f&&console.time("loadDatabase");let i=d(e=>{f&&console.timeEnd("loadDatabase"),o.operationInProgress=!1,n(e)},"finish");this._getAllChunks(t,e=>{try{if(!Array.isArray(e))throw e;if(!e.length)return i(null);f&&console.log("Found chunks:",e.length),e=M(e);let s=e.loki;return e.loki=null,A(s,e.chunkMap,o.options.deserializeChunk,o.lazyCollections),e=null,o._prevLokiVersionId=s.idbVersionId||null,o._prevCollectionVersionIds={},s.collections.forEach(({name:l,idbVersionId:a})=>{o._prevCollectionVersionIds[l]=a||null}),i(s)}catch(s){return o._prevLokiVersionId=null,o._prevCollectionVersionIds={},i(s)}})}_initializeIDB(t,n,o){let i=this;if(f&&console.log("initializing idb"),this.idbInitInProgress)throw new Error("Cannot open IndexedDB because open is already in progress");this.idbInitInProgress=!0;let e=indexedDB.open(t,1);e.onupgradeneeded=({target:s,oldVersion:l})=>{let a=s.result;if(f&&console.log(`onupgradeneeded, old version: ${l}`),l<1)a.createObjectStore("LokiIncrementalData",{keyPath:"key"});else throw new Error(`Invalid old version ${l} for IndexedDB upgrade`)},e.onsuccess=({target:s})=>{i.idbInitInProgress=!1;let l=s.result;if(i.idb=l,!l.objectStoreNames.contains("LokiIncrementalData")){n(new Error("Missing LokiIncrementalData")),i.deleteDatabase(t);return}f&&console.log("init success"),l.onversionchange=a=>{i.idb===l&&(f&&console.log("IDB version change",a),i.idb.close(),i.idb=null,i.options.onversionchange&&i.options.onversionchange(a))},o()},e.onblocked=s=>{console.error("IndexedDB open is blocked",s),n(new Error("IndexedDB open is blocked by open connection"))},e.onerror=s=>{i.idbInitInProgress=!1,console.error("IndexedDB open error",s),n(s)}}_getAllChunks(t,n){let o=this;if(!this.idb){this._initializeIDB(t,n,()=>{o._getAllChunks(t,n)});return}let e=this.idb.transaction(["LokiIncrementalData"],"readonly").objectStore("LokiIncrementalData"),s=this.options.deserializeChunk,l=this.lazyCollections;function a(k){let h=o.megachunkCount,u=R(k,h),g=[],p=0;function I({target:v},D,y){let C="processing chunk "+D+" ("+y.lower+" -- "+y.upper+")";f&&console.time(C);let _=v.result;_.forEach((P,L)=>{x(P,s,l),g.push(P),_[L]=null}),f&&console.timeEnd(C),p+=1,p===h&&n(g)}d(I,"processMegachunk");let b=2,S=h/b;function z(v,D){let y=u[v];w(e.getAll(y),C=>{D<b&&z(v+S,D+1),I(C,v,y)},C=>{n(C)})}d(z,"requestMegachunk");for(let v=0;v<S;v+=1)z(v,1)}d(a,"getMegachunks");function m(){w(e.getAll(),({target:k})=>{let h=k.result;h.forEach(u=>{x(u,s,l)}),n(h)},k=>{n(k)})}d(m,"getAllChunks");function c(){function k(h){h.sort(),h.length>100?a(h):m()}d(k,"onDidGetKeys"),w(e.getAllKeys(),({target:h})=>{k(h.result)},h=>{n(h)}),o.options.onFetchStart&&o.options.onFetchStart()}d(c,"getAllKeys"),c()}deleteDatabase(t,n){if(this.operationInProgress)throw new Error("Error while deleting database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0;let o=this;f&&console.log("deleteDatabase - begin"),f&&console.time("deleteDatabase"),this._prevLokiVersionId=null,this._prevCollectionVersionIds={},this.idb&&(this.idb.close(),this.idb=null);let i=indexedDB.deleteDatabase(t);i.onsuccess=()=>{o.operationInProgress=!1,f&&console.timeEnd("deleteDatabase"),n({success:!0})},i.onerror=e=>{o.operationInProgress=!1,console.error("Error while deleting database",e),n({success:!1})},i.onblocked=e=>{console.error("Deleting database failed because it's blocked by another connection",e)}}};d(E,"IncrementalIndexedDBAdapter");function B(r){let t={};return r.forEach(n=>{let o=n.split(".");if(o.length===3&&o[1]==="chunk"){let i=o[0],e=parseInt(o[2])||0,s=t[i];(!s||e>s)&&(t[i]=e)}}),t}d(B,"getMaxChunkIds");function N(r){try{return r&&JSON.parse(r.value).idbVersionId||null}catch(t){return console.error("Error while parsing loki chunk",t),null}}d(N,"lokiChunkVersionId");function M(r){let t,n={};if(K(r),r.forEach(o=>{let i=o.type,e=o.value,s=o.collectionName;if(i==="loki")t=e;else if(i==="data")n[s]?n[s].dataChunks.push(e):n[s]={metadata:null,dataChunks:[e]};else if(i==="metadata")n[s]?n[s].metadata=e:n[s]={metadata:e,dataChunks:[]};else throw new Error("unreachable")}),!t)throw new Error("Corrupted database - missing database metadata");return{loki:t,chunkMap:n}}d(M,"chunksToMap");function A({collections:r},t,n,o){r.forEach(d(function(e,s){let l=e.name,a=t[l];if(a){if(!a.metadata)throw new Error(`Corrupted database - missing metadata chunk for ${l}`);let m=a.metadata;a.metadata=null,r[s]=m;let c=o.includes(l),k=d(()=>{f&&c&&console.log(`lazy loading ${l}`);let h=[],u=a.dataChunks;return u.forEach(d(function(p,I){c&&(p=JSON.parse(p),n&&(p=n(l,p))),p.forEach(b=>{h.push(b)}),u[I]=null},"populateChunk")),h},"lokiDeserializeCollectionChunks");m.getData=k}},"populateCollection"))}d(A,"populateLoki");function O(r){let t=r.key;if(t==="loki"){r.type="loki";return}else if(t.includes(".")){let n=t.split(".");if(n.length===3&&n[1]==="chunk"){r.type="data",r.collectionName=n[0],r.index=parseInt(n[2],10);return}else if(n.length===2&&n[1]==="metadata"){r.type="metadata",r.collectionName=n[0];return}}throw console.error(`Unknown chunk ${t}`),new Error("Corrupted database - unknown chunk found")}d(O,"classifyChunk");function x(r,t,n){O(r);let o=r.type==="data",i=n.includes(r.collectionName);o&&i||(r.value=JSON.parse(r.value)),t&&o&&!i&&(r.value=t(r.collectionName,r.value))}d(x,"parseChunk");function V(){return Math.random().toString(36).substring(2)}d(V,"randomVersionId");function K(r){r.sort(function(t,n){return(t.index||0)-(n.index||0)})}d(K,"sortChunksInPlace");function R(r,t){let n=Math.floor(r.length/t),o=[],i,e;for(let s=0;s<t;s+=1)i=r[n*s],e=r[n*(s+1)],s===0?o.push(IDBKeyRange.upperBound(e,!0)):s===t-1?o.push(IDBKeyRange.lowerBound(i)):o.push(IDBKeyRange.bound(i,e,!1,!0));return o}d(R,"createKeyRanges");function w(r,t,n){return r.onsuccess=o=>{try{return t(o)}catch(i){n(i)}},r.onerror=n,r}d(w,"idbReq");window!==void 0&&Object.assign(window,{IncrementalIndexedDBAdapter:E});export{E as IncrementalIndexedDBAdapter};
//# sourceMappingURL=incremental-indexeddb-adapter.js.map
