var L=Object.defineProperty;var l=(r,t)=>L(r,"name",{value:t,configurable:!0});var C=(r,t,e)=>{if(!t.has(r))throw TypeError("Cannot "+e)};var A=(r,t,e)=>(C(r,t,"read from private field"),e?e.call(r):t.get(r)),D=(r,t,e)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,e)},m=(r,t,e,s)=>(C(r,t,"write to private field"),s?s.call(r,e):t.set(r,e),e);var x=(r,t,e)=>(C(r,t,"access private method"),e);var h=(r,t,e)=>new Promise((s,o)=>{var n=c=>{try{i(e.next(c))}catch(d){o(d)}},a=c=>{try{i(e.throw(c))}catch(d){o(d)}},i=c=>c.done?s(c.value):Promise.resolve(c.value).then(n,a);i((e=e.apply(r,t)).next())});function q(r){if(r.length%4!==0)throw new Error("Unable to parse base64 string (invalid length).");let t=r.indexOf("=");if(t!==-1&&t<r.length-2)throw new Error("Unable to parse base64 string (octets).");let e=r.endsWith("==")?2:r.endsWith("=")?1:0,s=r.length,o=new Uint8Array(3*(s/4)),n;for(let a=0,i=0;a<s;a+=4,i+=3)n=E(r.charCodeAt(a))<<18|E(r.charCodeAt(a+1))<<12|E(r.charCodeAt(a+2))<<6|E(r.charCodeAt(a+3)),o[i]=n>>16,o[i+1]=n>>8&255,o[i+2]=n&255;return o.subarray(0,o.length-e)}l(q,"base64ToBytes");var f=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","_","-"],T=(()=>{let t=new Uint8Array(256);for(let e=0;e<256;++e)t[e]=255;return f.forEach((e,s)=>{t[e.charCodeAt(0)]=s}),t["=".charCodeAt(0)]=0,t})();function E(r){if(r>=T.length)throw new Error("Unable to parse base64 string (code beyond length).");let t=T[r];if(t===255)throw new Error("Unable to parse base64 string (invalid code).");return t}l(E,"getBase64Code");function G(r){let t="",e,s=r.length;for(e=2;e<s;e+=3)t+=f[r[e-2]>>2],t+=f[(r[e-2]&3)<<4|r[e-1]>>4],t+=f[(r[e-1]&15)<<2|r[e]>>6],t+=f[r[e]&63];return e===s+1&&(t+=f[r[e-2]>>2],t+=f[(r[e-2]&3)<<4],t+="=="),e===s&&(t+=f[r[e-2]>>2],t+=f[(r[e-2]&3)<<4|r[e-1]>>4],t+=f[(r[e-1]&15)<<2],t+="="),t}l(G,"bytesToBase64");var V=l(r=>{let t=new TextEncoder;return window.crypto.subtle.importKey("raw",t.encode(r),"PBKDF2",!1,["deriveKey"])},"getPasswordKey"),U=l((r,t,e)=>window.crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:25e4,hash:"SHA-256"},r,{name:"AES-GCM",length:256},!1,e),"deriveKey");function R(r,t){return h(this,null,function*(){try{let e=window.crypto.getRandomValues(new Uint8Array(16)),s=window.crypto.getRandomValues(new Uint8Array(12)),o=yield V(t),n=yield U(o,e,["encrypt"]),a=yield window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},n,new TextEncoder().encode(r)),i=new Uint8Array(a),c=new Uint8Array(e.byteLength+s.byteLength+i.byteLength);return c.set(e,0),c.set(s,e.byteLength),c.set(i,e.byteLength+s.byteLength),G(c)}catch(e){throw console.log(`Encryption Error - ${e}`),e}})}l(R,"encryptData");function S(r,t){return h(this,null,function*(){try{let e=q(r),s=e.slice(0,16),o=e.slice(16,16+12),n=e.slice(16+12),a=yield V(t),i=yield U(a,s,["decrypt"]),c=yield window.crypto.subtle.decrypt({name:"AES-GCM",iv:o},i,n);return new TextDecoder().decode(c)}catch(e){throw console.log(`Decryption Error - ${e}`),e}})}l(S,"decryptData");var B,$,g=class{constructor(){D(this,B);this.db=null}initialize(){return new Promise((t,e)=>{x(this,B,$).call(this).then(s=>{t(s)}).catch(s=>{console.log(s),e(s)})})}openCatalog(){let t=indexedDB.open("IDBCatalog",1);return t.onupgradeneeded=({target:e})=>{let s=e.result;if(s.objectStoreNames.contains("IDBAKV")&&s.deleteObjectStore("IDBAKV"),!s.objectStoreNames.contains("IDBAKV")){let o=s.createObjectStore("IDBAKV",{keyPath:"id",autoIncrement:!0});o.createIndex("app","app",{unique:!1}),o.createIndex("key","key",{unique:!1}),o.createIndex("appkey","appkey",{unique:!0})}},t}getAppKeyAsync(t,e){return h(this,null,function*(){let n=this.db.transaction(["IDBAKV"],"readonly").objectStore("IDBAKV").index("appkey"),a=`${t},${e}`,i=n.get(a);return new Promise((c,d)=>{i.onsuccess=({target:u})=>{let p=u.result;(p===null||typeof p=="undefined")&&(p={id:0,success:!1}),c(p)},i.onerror=u=>{d(u)}})})}setAppKeyAsync(t,e,s){return h(this,null,function*(){let n=this.db.transaction(["IDBAKV"],"readwrite").objectStore("IDBAKV"),a=n.index("appkey"),i=`${t},${e}`,c=a.get(i);return new Promise((d,u)=>{c.onsuccess=({target:p})=>{let b=p.result;b==null?b={app:t,key:e,appkey:`${t},${e}`,val:s}:b.val=s;let I=n.put(b);I.onerror=()=>{u({success:!1,error:I.error}),console.error("IDBCatalog.setAppKey (set) onerror"),console.error(c.error)},I.onsuccess=()=>{d({success:!0})}},c.onerror=()=>{u({success:!1,error:c.error}),console.error("IDBCatalog.setAppKey (get) onerror"),console.error(c.error)}})})}deleteAppKeyAsync(t){let o=this.db.transaction(["IDBAKV"],"readwrite").objectStore("IDBAKV").delete(t);return new Promise((n,a)=>{o.onsuccess=()=>{n({success:!0})},o.onerror=i=>{a({success:!1,error:i}),console.error("IDBCatalog.deleteAppKey raised onerror"),console.error(o.error)}})}getAppKeysAsync(t){return h(this,null,function*(){let o=this.db.transaction(["IDBAKV"],"readonly").objectStore("IDBAKV").index("app"),n=IDBKeyRange.only(t),a=o.openCursor(n),i=[];return new Promise((c,d)=>{a.onsuccess=()=>{let u=a.result;if(u){let p=u.value;i.push(p),u.continue()}else c(i)},a.onerror=u=>{d(u)}})})}getAppKeys(t,e){let n=this.db.transaction(["IDBAKV"],"readonly").objectStore("IDBAKV").index("app"),a=IDBKeyRange.only(t),i=n.openCursor(a),c=[];i.onsuccess=((d,u)=>()=>{let p=i.result;if(p){let b=p.value;d.push(b),p.continue()}else typeof u=="function"?u(d):console.log(d)})(c,e),i.onerror=(d=>u=>{typeof d=="function"?d(null):(console.error("IDBCatalog.getAppKeys raised onerror"),console.error(u))})(e)}};l(g,"IDBCatalog"),B=new WeakSet,$=l(function(){return h(this,null,function*(){let t=this,e=this.openCatalog();return new Promise((s,o)=>{e.onsuccess=({target:n})=>{t.db=n.result,s(t)},e.onerror=n=>{o(n)}})})},"#initializeCatalog");var w=typeof window!="undefined"&&!!window.__loki_idb_debug;w&&console.log("DEBUG: Running crypted-indexeddb-adapter in DEBUG mode");if(!window.crypto.subtle)throw alert("Required crypto lib is not available, are you using SSL?"),new Error("Required crypto lib is not available");var y,K,v,z,P=class{constructor(t){D(this,v);D(this,y,void 0);D(this,K,l(()=>{this.catalog&&this.catalog.db&&(this.catalog.db.close(),this.catalog.db=null)},"#closeDatabase"));this.loadDatabase=l((t,e)=>{if(w&&console.debug("loading database"),this.catalog===null||this.catalog.db===null){new g().initialize().then(s=>{this.catalog=s,this.loadDatabase(t,e)});return}this.catalog.getAppKeyAsync(this.app,t).then(s=>{let{success:o}=s;if(o===!1)e(null);else{let{val:n}=s;S(n,A(this,y)).then(a=>{w&&console.debug(`DECRYPTED STRING: ${a}`),e(a)}).catch(a=>{console.error(a),e(a)})}}).catch(s=>{console.error(s),e(s)})},"loadDatabase");this.loadDatabaseAsync=l(t=>h(this,null,function*(){return w&&console.debug("loading database"),new Promise((e,s)=>{let o=l(()=>this.catalog.getAppKeyAsync(this.app,t).then(n=>{let{success:a}=n;if(a===!1)s(null);else{let{val:i}=n;S(i,A(this,y)).then(d=>{w&&console.debug(`DECRYPTED STRING: ${d}`),e(d)}).catch(d=>{s(d)})}}),"doLoad");this.catalog===null||this.catalog.db===null?new g().initialize().then(n=>{this.catalog=n,o()}).catch(n=>{s(n)}):o()})}),"loadDatabaseAsync");this.saveDatabase=l((t,e,s)=>{w&&console.debug(`in saveDatabase(${t}, ${e}, ${s})`);let o=l(()=>R(e,A(this,y)).then(n=>{w&&console.debug(`ENCRYPTED STRING: ${n}`),this.catalog.setAppKeyAsync(this.app,t,n).then(a=>{s(a)}).catch(a=>{s(a)})}).catch(n=>{s(n)}),"doSave");this.catalog===null||this.catalog.db===null?new g().initialize().then(n=>{this.catalog=n,this.saveDatabaseAsync(t,e).then(()=>{s(void 0)}).catch(a=>{s(new Error("Error saving database: "+a))}).finally(()=>{this.options.closeAfterSave===!0&&A(this,K).call(this)})}).catch(n=>{s(new Error("Error saving database: "+n))}):o()},"saveDatabase");this.deleteDatabase=l((t,e)=>{if(this.catalog===null||this.catalog.db===null){new g().initialize().then(s=>{this.catalog=s,this.deleteDatabase(t,e)}).catch(s=>{e(new Error("Error deleting database: "+s))});return}this.catalog.getAppKeyAsync(this.app,t).then(s=>{let o=s.id;o!==0&&this.catalog.deleteAppKeyAsync(o).then(n=>{typeof e=="function"&&e(n)}).catch(n=>{typeof e=="function"&&e({success:!1,error:n})})}).catch(s=>{typeof e=="function"&&e({success:!1,error:s})})},"deleteDatabase");this.deleteDatabasePartitions=l(t=>{this.getDatabaseList(e=>{if(e instanceof Error)throw e;e.forEach(s=>{s.startsWith(t)&&this.deleteDatabase(s)})})},"deleteDatabasePartitions");this.getDatabaseList=l(t=>{if(this.catalog===null||this.catalog.db===null){new g().initialize().then(e=>{this.catalog=e,this.getDatabaseList(t)}).catch(e=>{t(new Error("Error getting database list: "+e))});return}this.catalog.getAppKeys(this.app,e=>{let s=[];for(let o=0;o<e.length;o++)s.push(e[o].key);typeof t=="function"?t(s):s.forEach(o=>{console.log(o)})})},"getDatabaseList");this.getDatabaseListAsync=l(()=>new Promise((t,e)=>{this.catalog===null||this.catalog.db===null?new g().initialize().then(s=>{this.catalog=s,this.catalog.getAppKeysAsync(this.app).then(o=>{let n=o.map(a=>a.key);t(n)}).catch(o=>{e(o)})}).catch(s=>{e(s)}):this.catalog.getAppKeysAsync(this.app).then(s=>{let o=s.map(n=>n.key);t(o)}).catch(s=>{e(s)})}),"getDatabaseListAsync");if(w&&console.log("Initialized crypted-indexeddb-adapter"),this.app="sylvie",this.options=t||{},typeof(t==null?void 0:t.appname)!="undefined"&&(this.app=t==null?void 0:t.appname),this.catalog=null,!x(this,v,z).call(this))throw new Error("IndexedDB does not seem to be supported for your environment");t.secret&&m(this,y,t.secret)}usePassword(t){m(this,y,t)}saveDatabaseAsync(t,e){return h(this,null,function*(){return new Promise((s,o)=>{let n=l(()=>R(e,A(this,y)).then(a=>{w&&console.debug(`ENCRYPTED STRING: ${a}`),this.catalog.setAppKeyAsync(this.app,t,a).then(i=>{i.success===!0?s():o(i)}).catch(i=>{o(i)})}).catch(a=>{o(a)}),"doSave");this.catalog===null||this.catalog.db===null?new g().initialize().then(a=>{this.catalog=a,this.saveDatabaseAsync(t,e).then(s).catch(i=>{o(new Error("Error saving database: "+i))}).finally(()=>{this.options.closeAfterSave===!0&&A(this,K).call(this)})}).catch(a=>{o(a)}):n()})})}deleteDatabaseAsync(t){return h(this,null,function*(){return new Promise((e,s)=>{let o=l(()=>this.catalog.getAppKeyAsync(this.app,t).then(n=>{let a=n.id;a!==0&&this.catalog.deleteAppKeyAsync(a).then(i=>{i.success===!0?e():s(i)}).catch(i=>{s(i)})}).catch(n=>{s(n)}),"doDelete");this.catalog===null||this.catalog.db===null?new g().initialize().then(n=>{this.catalog=n,o()}).catch(n=>{s(n)}):o()})})}changePassword(t,e){return h(this,null,function*(){return new Promise((s,o)=>{this.loadDatabase(t,n=>{let a=A(this,y);m(this,y,e),this.saveDatabase(t,n,i=>{i&&(m(this,y,a),i.success===!0?s():o(i)),s()})})})})}};l(P,"CryptedIndexedDBAdapter"),y=new WeakMap,K=new WeakMap,v=new WeakSet,z=l(function(){return!!(typeof indexedDB!="undefined"&&indexedDB)},"#checkIDBAvailability");typeof window!="undefined"&&Object.assign(window,{CryptedIndexedDBAdapter:P});export{P as CryptedIndexedDBAdapter};
//# sourceMappingURL=crypted-indexeddb-adapter.js.map
