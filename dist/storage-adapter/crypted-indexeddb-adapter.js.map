{
  "version": 3,
  "sources": ["../../src/storage-adapter/crypted-indexeddb-adapter/string-encryption-utils.ts", "../../src/storage-adapter/crypted-indexeddb-adapter/idb-catalog.ts", "../../src/storage-adapter/crypted-indexeddb-adapter.ts"],
  "sourcesContent": ["export function base64ToBytes(str: string) {\n  if (str.length % 4 !== 0) {\n    throw new Error(\"Unable to parse base64 string (invalid length).\");\n  }\n  const index = str.indexOf(\"=\");\n  if (index !== -1 && index < str.length - 2) {\n    throw new Error(\"Unable to parse base64 string (octets).\");\n  }\n  const missingOctets = str.endsWith(\"==\") ? 2 : str.endsWith(\"=\") ? 1 : 0,\n    n = str.length,\n    result = new Uint8Array(3 * (n / 4));\n  let buffer;\n  for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n    buffer =\n      (getBase64Code(str.charCodeAt(i)) << 18) |\n      (getBase64Code(str.charCodeAt(i + 1)) << 12) |\n      (getBase64Code(str.charCodeAt(i + 2)) << 6) |\n      getBase64Code(str.charCodeAt(i + 3));\n    result[j] = buffer >> 16;\n    result[j + 1] = (buffer >> 8) & 255;\n    result[j + 2] = buffer & 255;\n  }\n  return result.subarray(0, result.length - missingOctets);\n}\n\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"_\",\n  \"-\",\n];\n\nexport const base64codes = (() => {\n  const l = 256;\n  const base64codes = new Uint8Array(l);\n  for (let i = 0; i < l; ++i) {\n    base64codes[i] = 255; // invalid character\n  }\n  base64abc.forEach((char, index) => {\n    base64codes[char.charCodeAt(0)] = index;\n  });\n  base64codes[\"=\".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error\n  return base64codes;\n})();\n\nexport function getBase64Code(charCode: number) {\n  if (charCode >= base64codes.length) {\n    throw new Error(\"Unable to parse base64 string (code beyond length).\");\n  }\n  const code = base64codes[charCode]!;\n  if (code === 255) {\n    throw new Error(\"Unable to parse base64 string (invalid code).\");\n  }\n  return code;\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  let result = \"\",\n    i,\n    l = bytes.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[((bytes[i - 2]! & 0x03) << 4) | (bytes[i - 1]! >> 4)];\n    result += base64abc[((bytes[i - 1]! & 0x0f) << 2) | (bytes[i]! >> 6)];\n    result += base64abc[bytes[i]! & 0x3f];\n  }\n  if (i === l + 1) {\n    // 1 octet yet to write\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[(bytes[i - 2]! & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === l) {\n    // 2 octets yet to write\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[((bytes[i - 2]! & 0x03) << 4) | (bytes[i - 1]! >> 4)];\n    result += base64abc[(bytes[i - 1]! & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n}\n\nexport function base64encode(str: string, encoder = new TextEncoder()) {\n  return bytesToBase64(encoder.encode(str));\n}\n\nexport function base64decode(str: string, decoder = new TextDecoder()) {\n  return decoder.decode(base64ToBytes(str));\n}\n\nexport const getPasswordKey = (password) => {\n  const enc = new TextEncoder();\n  return window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    \"PBKDF2\",\n    false,\n    [\"deriveKey\"]\n  );\n};\n\nexport const deriveKey = (passwordKey, salt, keyUsage) =>\n  window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 250000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    keyUsage\n  );\n\nexport async function encryptData(secretData, password) {\n  try {\n    const salt = window.crypto.getRandomValues(new Uint8Array(16));\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    const passwordKey = await getPasswordKey(password);\n    const aesKey = await deriveKey(passwordKey, salt, [\"encrypt\"]);\n    const encryptedContent = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      aesKey,\n      new TextEncoder().encode(secretData)\n    );\n\n    const encryptedContentArr = new Uint8Array(encryptedContent);\n    const buff = new Uint8Array(\n      salt.byteLength + iv.byteLength + encryptedContentArr.byteLength\n    );\n    buff.set(salt, 0);\n    buff.set(iv, salt.byteLength);\n    buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n    const base64Buff = bytesToBase64(buff);\n    return base64Buff;\n  } catch (e) {\n    console.log(`Encryption Error - ${e}`);\n    throw e;\n  }\n}\n\nexport async function decryptData(encryptedData, password) {\n  try {\n    const encryptedDataBuff = base64ToBytes(encryptedData);\n    const salt = encryptedDataBuff.slice(0, 16);\n    const iv = encryptedDataBuff.slice(16, 16 + 12);\n    const data = encryptedDataBuff.slice(16 + 12);\n    const passwordKey = await getPasswordKey(password);\n\n    const aesKey = await deriveKey(passwordKey, salt, [\"decrypt\"]);\n    const decryptedContent = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      aesKey,\n      data\n    );\n    return new TextDecoder().decode(decryptedContent);\n  } catch (e) {\n    console.log(`Decryption Error - ${e}`);\n    throw e;\n  }\n}\n", "export type SuccessResultType = { success: true };\nexport type FailResultType = { success: false; error: Error };\nexport type ResultType = SuccessResultType | FailResultType;\n/**\n * IDBCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence\n *    using IndexedDBAdapter.\n */\nexport class IDBCatalog {\n  db?: IDBDatabase;\n  constructor() {\n    this.db = null;\n  }\n\n  /**\n   * Asynchronously initializes the catalog the database after creation. Must be run after the database is constructed but before using the database.\n   */\n  initialize(): Promise<IDBCatalog> {\n    return new Promise((resolve, reject) => {\n      this.#initializeCatalog()\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((err) => {\n          console.log(err);\n          reject(err);\n        });\n    });\n  }\n\n  openCatalog() {\n    const openRequest = indexedDB.open(\"IDBCatalog\", 1);\n\n    openRequest.onupgradeneeded = ({ target }) => {\n      const thisDB = (target as any).result;\n      if (thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        thisDB.deleteObjectStore(\"IDBAKV\");\n      }\n\n      if (!thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        const objectStore = thisDB.createObjectStore(\"IDBAKV\", {\n          keyPath: \"id\",\n          autoIncrement: true,\n        });\n        objectStore.createIndex(\"app\", \"app\", { unique: false });\n        objectStore.createIndex(\"key\", \"key\", { unique: false });\n        objectStore.createIndex(\"appkey\", \"appkey\", { unique: true });\n      }\n    };\n\n    return openRequest;\n  }\n\n  async #initializeCatalog(): Promise<IDBCatalog> {\n    const cat = this;\n    const openRequest = this.openCatalog();\n\n    return new Promise((resolve, reject) => {\n      openRequest.onsuccess = ({ target }) => {\n        cat.db = (target as any).result;\n        resolve(cat);\n      };\n\n      openRequest.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  async getAppKeyAsync(\n    app,\n    key\n  ): Promise<\n    | {\n        app: string;\n        appkey: string;\n        id: number;\n        key: string;\n        val: string;\n      }\n    | {\n        id: 0;\n        success: false;\n      }\n  > {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let lres = (target as any).result;\n\n        if (lres === null || typeof lres === \"undefined\") {\n          lres = {\n            id: 0,\n            success: false,\n          };\n        }\n\n        resolve(lres);\n      };\n\n      request.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  async setAppKeyAsync(app, key, val): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let res = (target as any).result;\n\n        if (res === null || res === undefined) {\n          res = {\n            app,\n            key,\n            appkey: `${app},${key}`,\n            val,\n          };\n        } else {\n          res.val = val;\n        }\n\n        const requestPut = store.put(res);\n\n        requestPut.onerror = () => {\n          reject({ success: false, error: requestPut.error });\n          console.error(\"IDBCatalog.setAppKey (set) onerror\");\n          console.error(request.error);\n        };\n\n        requestPut.onsuccess = () => {\n          resolve({ success: true });\n        };\n      };\n\n      request.onerror = () => {\n        reject({ success: false, error: request.error });\n        console.error(\"IDBCatalog.setAppKey (get) onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  deleteAppKeyAsync(id): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const request = store.delete(id);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve({ success: true });\n      };\n\n      request.onerror = (e) => {\n        reject({ success: false, error: e });\n        console.error(\"IDBCatalog.deleteAppKey raised onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  async getAppKeysAsync(app): Promise<{ key: string }[]> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"app\");\n\n    // We want cursor to all values matching our (single) app param\n    const singleKeyRange = IDBKeyRange.only(app);\n\n    // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n    const cursor = index.openCursor(singleKeyRange);\n\n    // cursor internally, pushing results into this.data[] and return\n    // this.data[] when done (similar to service)\n    const localdata = [];\n\n    return new Promise((resolve, reject) => {\n      cursor.onsuccess = () => {\n        const cur = cursor.result;\n        if (cur) {\n          const currObject = cur.value;\n\n          localdata.push(currObject);\n\n          cur.continue();\n        } else {\n          resolve(localdata);\n        }\n      };\n\n      cursor.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  getAppKeys(app, callback) {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"app\");\n\n    // We want cursor to all values matching our (single) app param\n    const singleKeyRange = IDBKeyRange.only(app);\n\n    // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n    const cursor = index.openCursor(singleKeyRange);\n\n    // cursor internally, pushing results into this.data[] and return\n    // this.data[] when done (similar to service)\n    const localdata = [];\n\n    cursor.onsuccess = ((data, callback) => () => {\n      const cur = cursor.result;\n      if (cur) {\n        const currObject = cur.value;\n\n        data.push(currObject);\n\n        cur.continue();\n      } else {\n        if (typeof callback === \"function\") {\n          callback(data);\n        } else {\n          console.log(data);\n        }\n      }\n    })(localdata, callback);\n\n    cursor.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") {\n        usercallback(null);\n      } else {\n        console.error(\"IDBCatalog.getAppKeys raised onerror\");\n        console.error(e);\n      }\n    })(callback);\n  }\n}\n", "/**\n  Sylvie IndexedDb Adapter (need to include this script to use it)\n*/\nimport {\n  decryptData,\n  encryptData,\n} from \"./crypted-indexeddb-adapter/string-encryption-utils\";\nimport { IDBCatalog } from \"./crypted-indexeddb-adapter/idb-catalog\";\nimport {\n  AsyncPersistenceAdapter,\n  NormalSyncPersistenceAdapter,\n} from \"./persistence-adapter\";\n\n// @ts-ignore\nconst DEBUG = typeof window !== \"undefined\" && !!window.__loki_idb_debug;\n\nif (DEBUG) {\n  console.log(\"DEBUG: Running crypted-indexeddb-adapter in DEBUG mode\");\n}\n\nif (!window.crypto.subtle) {\n  alert(\"Required crypto lib is not available, are you using SSL?\");\n  throw new Error(\"Required crypto lib is not available\");\n}\n\ninterface CryptedIndexedDBAdapterOptions {\n  appname: string;\n  closeAfterSave: boolean;\n  secret: string;\n}\n\n/**\n * Loki/Sylvie encrypted persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included SylvieCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new CryptedIndexedDBAdapter('finance', {\n *  secret: \"pass\"\n * });\n *\n */\nexport class CryptedIndexedDBAdapter\n  implements NormalSyncPersistenceAdapter, AsyncPersistenceAdapter\n{\n  isAsync: true;\n  app: string;\n  options: Partial<CryptedIndexedDBAdapterOptions>;\n  catalog: IDBCatalog;\n  mode: \"normal\";\n  #secret: string;\n\n  /**\n   * Create a CryptedIndexedDBAdapter.\n   * @param {CryptedIndexedDBAdapterOptions} options Configuration options for the adapter\n   * @param {string} options.appname - (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n   * @param {boolean} options.closeAfterSave Whether the indexedDB database should be closed after saving.\n   * @param {boolean} options.secret The password to encrypt with.\n   */\n  constructor(options?: Partial<CryptedIndexedDBAdapterOptions>) {\n    DEBUG && console.log(\"Initialized crypted-indexeddb-adapter\");\n    this.app = \"sylvie\";\n    this.options = options || {};\n\n    if (typeof options?.appname !== \"undefined\") {\n      this.app = options?.appname;\n    }\n\n    // keep reference to catalog class for base AKV operations\n    this.catalog = null;\n\n    if (!this.#checkIDBAvailability()) {\n      throw new Error(\n        \"IndexedDB does not seem to be supported for your environment\",\n      );\n    }\n\n    if (options.secret) {\n      this.#secret = options.secret;\n    }\n  }\n\n  /**\n   * Sets a password for use on future load and save of the database.\n   * Note that this does not re-encrypt the database with the new password. Use changePassword() for that.\n   * @param secret\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *   adapter: new CryptedIndexedDBAdapter();\n   * });\n   *\n   * adapter.usePassword(\"newpassword\");\n   *\n   * await newDb.loadDatabaseAsync({});\n   */\n  usePassword(secret: string) {\n    this.#secret = secret;\n  }\n\n  /**\n   * Used for closing the indexeddb database.\n   */\n  #closeDatabase = () => {\n    if (this.catalog && this.catalog.db) {\n      this.catalog.db.close();\n      this.catalog.db = null;\n    }\n  };\n\n  /**\n   * Used to check if adapter is available\n   *\n   * @returns {boolean} true if indexeddb is available, false if not.\n   */\n  #checkIDBAvailability(): boolean {\n    if (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n    return false;\n  }\n\n  /**\n   * Retrieves a serialized db string from the catalog.\n   *\n   * @example\n   * // LOAD\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   *   db.loadDatabase(function(result) {\n   *   console.log('done');\n   * });\n   *\n   * @param {string} dbname - the name of the database to retrieve.\n   * @param {function} callback - callback should accept string param containing serialized db string.\n   */\n  loadDatabase = (dbname: string, callback: (serialized: string) => void) => {\n    DEBUG && console.debug(\"loading database\");\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog().initialize().then((catalog) => {\n        this.catalog = catalog;\n        this.loadDatabase(dbname, callback);\n        return;\n      });\n      return;\n    }\n\n    // lookup up dbstring in AKV db\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((props) => {\n        const { success } = props as { success: boolean };\n        if (success === false) {\n          callback(null);\n        } else {\n          const { val: encryptedDbString } = props as { val: string };\n          decryptData(encryptedDbString, this.#secret)\n            .then((decryptedDbString) => {\n              DEBUG && console.debug(`DECRYPTED STRING: ${decryptedDbString}`);\n              callback(decryptedDbString);\n            })\n            .catch((err) => {\n              console.error(err);\n              callback(err);\n            });\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        callback(err);\n      });\n  };\n\n  /**\n   * Retrieves a serialized db string from the catalog, returns a promise to a string of the serialized database.\n   * @param dbname\n   * @returns {Promise<string>} A promise to a string of the serialized database.\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *  adapter: new CryptedIndexedDBAdapter();\n   * });\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * // you can also chain the promises\n   * await db.loadDatabaseAsync({}).then(() => {\n   * // db is now ready to use\n   * });\n   * // or use async await syntax\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * @memberof CryptedIndexedDBAdapter\n   * @throws {Error} If the database is not found.\n   * @throws {Error} If the database is not decrypted successfully.\n   * @throws {Error} If the database is not deserialized successfully.\n   */\n  loadDatabaseAsync = async (dbname: string): Promise<string> => {\n    DEBUG && console.debug(\"loading database\");\n\n    return new Promise((resolve, reject) => {\n      const doLoad = () =>\n        this.catalog.getAppKeyAsync(this.app, dbname).then((props) => {\n          const { success } = props as { success: boolean };\n          if (success === false) {\n            reject(null);\n          } else {\n            const { val } = props as { val: string };\n            const encryptedDbString = val;\n            decryptData(encryptedDbString, this.#secret)\n              .then((decryptedDbString) => {\n                DEBUG &&\n                  console.debug(`DECRYPTED STRING: ${decryptedDbString}`);\n                resolve(decryptedDbString);\n              })\n              .catch((err) => {\n                reject(err);\n              });\n          }\n        });\n\n      // lazy open/create db reference so dont -need- callback in constructor\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doLoad();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doLoad();\n      }\n    });\n  };\n\n  /**\n   * Saves a serialized db to the catalog.\n   *\n   * @example\n   * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   * var coll = db.addCollection('testColl');\n   * coll.insert({test: 'val'});\n   * db.saveDatabase();  // could pass callback if needed for async complete\n   *\n   * @param {string} dbname - the name to give the serialized database within the catalog.\n   * @param {string} dbstring - the serialized db string to save.\n   * @param {function} callback - (Optional) callback passed obj.success with true or false\n   */\n  saveDatabase = (\n    dbname: string,\n    dbstring: string,\n    callback?: (\n      err: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) => {\n    DEBUG &&\n      console.debug(`in saveDatabase(${dbname}, ${dbstring}, ${callback})`);\n\n    const doSave = () =>\n      encryptData(dbstring, this.#secret)\n        .then((encryptedDbString) => {\n          // lazy open/create db reference so dont -need- callback in constructor\n          DEBUG && console.debug(`ENCRYPTED STRING: ${encryptedDbString}`);\n          // set (add/update) entry to AKV database\n          this.catalog\n            .setAppKeyAsync(this.app, dbname, encryptedDbString)\n            .then((res) => {\n              callback(res);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        })\n        .catch((err) => {\n          callback(err);\n        });\n\n    if (this.catalog === null || this.catalog.db === null) {\n      // catalog not initialized yet\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.saveDatabaseAsync(dbname, dbstring)\n            .then(() => {\n              callback(undefined);\n            })\n            .catch((err) => {\n              callback(new Error(\"Error saving database: \" + err));\n            })\n            .finally(() => {\n              if (this.options.closeAfterSave === true) {\n                this.#closeDatabase();\n              }\n            });\n        })\n        .catch((err) => {\n          callback(new Error(\"Error saving database: \" + err));\n        });\n    } else {\n      // catalog was already initialized, so just lookup object and delete by id\n      doSave();\n    }\n  };\n\n  async saveDatabaseAsync(dbname: string, dbstring: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const doSave = () =>\n        encryptData(dbstring, this.#secret)\n          .then((encryptedDbString) => {\n            // lazy open/create db reference so dont -need- callback in constructor\n            DEBUG && console.debug(`ENCRYPTED STRING: ${encryptedDbString}`);\n            // set (add/update) entry to AKV database\n            this.catalog\n              .setAppKeyAsync(this.app, dbname, encryptedDbString)\n              .then((res) => {\n                if (res.success === true) {\n                  resolve();\n                } else {\n                  reject(res);\n                }\n              })\n              .catch((err) => {\n                reject(err);\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            // Now that catalog is initialized, try again\n            this.saveDatabaseAsync(dbname, dbstring)\n              .then(resolve)\n              .catch((error) => {\n                reject(new Error(\"Error saving database: \" + error));\n              })\n              .finally(() => {\n                if (this.options.closeAfterSave === true) {\n                  this.#closeDatabase();\n                }\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doSave();\n      }\n    });\n  }\n\n  /**\n   * Deletes a serialized db from the catalog.\n   *\n   * @example\n   * // DELETE DATABASE\n   * // delete 'finance'/'test' value from catalog\n   * idbAdapter.deleteDatabase('test', function {\n   *   // database deleted\n   * });\n   *\n   * @param {string} dbname - the name of the database to delete from the catalog.\n   * @param {function=} callback - (Optional) executed on database delete\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabase = (\n    dbname: string,\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => any,\n  ) => {\n    // lazy open/create db reference and pass callback ahead\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.deleteDatabase(dbname, callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error deleting database: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog was already initialized, so just lookup object and delete by id\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((result) => {\n        const id = result.id;\n        if (id !== 0) {\n          this.catalog\n            .deleteAppKeyAsync(id)\n            .then((res) => {\n              if (typeof callback === \"function\") {\n                callback(res);\n              }\n            })\n            .catch((err) => {\n              if (typeof callback === \"function\") {\n                callback({ success: false, error: err });\n              }\n            });\n        }\n      })\n      .catch((err) => {\n        if (typeof callback === \"function\") {\n          callback({ success: false, error: err });\n        }\n      });\n  };\n\n  async deleteDatabaseAsync(dbname: string): Promise<void> {\n    // lazy open/create db reference and pass callback ahead\n    return new Promise((resolve, reject) => {\n      const doDelete = () =>\n        this.catalog\n          .getAppKeyAsync(this.app, dbname)\n          .then((result) => {\n            const id = result.id;\n            if (id !== 0) {\n              this.catalog\n                .deleteAppKeyAsync(id)\n                .then((res) => {\n                  if (res.success === true) {\n                    resolve();\n                  } else {\n                    reject(res);\n                  }\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            }\n          })\n          .catch((err) => {\n            reject(err);\n          });\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doDelete();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doDelete();\n      }\n    });\n  }\n\n  /**\n   * Changes the password of a database and re-encrypts the database with the new password.\n   * @param {string} dbName The name of the database to change the password of.\n   * @param {string} newPassword The new password to encrypt the database with.\n   * @memberof CryptedIndexedDBAdapter\n   * @returns {Promise<void>} A promise that resolves when the password has been changed.\n   * @throws {Error} If the adapter is not open.\n   * @example\n   * await adapter.changePassword(\"mydb\", \"newpassword\");\n   * // The database \"mydb\" is now encrypted with the password \"newpassword\".\n   * // The old password will no longer work.\n   */\n  async changePassword(dbname: string, newPassword: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.loadDatabase(dbname, (serializedDbString) => {\n        const oldPassword = this.#secret;\n        this.#secret = newPassword;\n        this.saveDatabase(dbname, serializedDbString, (responseString) => {\n          if (responseString) {\n            this.#secret = oldPassword;\n            if ((responseString as { success: boolean }).success === true) {\n              resolve();\n            } else {\n              reject(responseString);\n            }\n          }\n          resolve();\n        });\n      });\n    });\n  }\n\n  /**\n   * Removes all database partitions and pages with the base filename passed in.\n   * This utility method does not (yet) guarantee async deletions will be completed before returning\n   *\n   * @param {string} dbname - the base filename which container, partitions, or pages are derived\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabasePartitions = (dbname) => {\n    this.getDatabaseList((result) => {\n      if (result instanceof Error) {\n        throw result;\n      }\n      result.forEach((str) => {\n        if (str.startsWith(dbname)) {\n          this.deleteDatabase(str);\n        }\n      });\n    });\n  };\n\n  /**\n   * Retrieves object array of catalog entries for current app.\n   *\n   * @example\n   * idbAdapter.getDatabaseList(function(result) {\n   *   // result is array of string names for that appcontext ('finance')\n   *   result.forEach(function(str) {\n   *     console.log(str);\n   *   });\n   * });\n   *\n   * @param {function} callback - should accept array of database names in the catalog for current app.\n   * @memberof SylvieIndexedAdapter\n   */\n  getDatabaseList = (callback: (_: string[] | Error) => void) => {\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.getDatabaseList(callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error getting database list: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog.getAppKeys(this.app, (results) => {\n      const names = [];\n\n      for (let idx = 0; idx < results.length; idx++) {\n        names.push(results[idx].key);\n      }\n\n      if (typeof callback === \"function\") {\n        callback(names);\n      } else {\n        names.forEach((obj) => {\n          console.log(obj);\n        });\n      }\n    });\n  };\n\n  getDatabaseListAsync = (): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n      // lazy open/create db reference\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            this.catalog\n              .getAppKeysAsync(this.app)\n              .then((results) => {\n                const names: string[] = results.map((result) => result.key);\n                resolve(names);\n              })\n              .catch((err) => {\n                reject(err);\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog already initialized\n        // get all keys for current appName, and transpose results so just string array\n        this.catalog\n          .getAppKeysAsync(this.app)\n          .then((results) => {\n            const names: string[] = results.map((result) => result.key);\n            resolve(names);\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      }\n    });\n  };\n}\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, {\n    CryptedIndexedDBAdapter: CryptedIndexedDBAdapter,\n  });\n}\n"],
  "mappings": "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",
  "names": ["base64ToBytes", "str", "index", "missingOctets", "n", "result", "buffer", "i", "j", "getBase64Code", "__name", "base64abc", "base64codes", "char", "charCode", "code", "bytesToBase64", "bytes", "l", "getPasswordKey", "__name", "password", "enc", "deriveKey", "passwordKey", "salt", "keyUsage", "encryptData", "secretData", "__async", "iv", "aesKey", "encryptedContent", "encryptedContentArr", "buff", "bytesToBase64", "decryptData", "encryptedData", "encryptedDataBuff", "base64ToBytes", "data", "decryptedContent", "_initializeCatalog", "initializeCatalog_fn", "IDBCatalog", "__privateAdd", "resolve", "reject", "__privateMethod", "res", "err", "openRequest", "target", "thisDB", "objectStore", "app", "key", "__async", "index", "appkey", "request", "lres", "e", "val", "store", "requestPut", "id", "singleKeyRange", "cursor", "localdata", "cur", "currObject", "callback", "data", "usercallback", "__name", "cat", "DEBUG", "_secret", "_closeDatabase", "_checkIDBAvailability", "checkIDBAvailability_fn", "CryptedIndexedDBAdapter", "options", "__privateAdd", "__name", "dbname", "callback", "IDBCatalog", "catalog", "props", "success", "encryptedDbString", "decryptData", "__privateGet", "decryptedDbString", "err", "__async", "resolve", "reject", "doLoad", "val", "dbstring", "doSave", "encryptData", "res", "result", "id", "str", "results", "names", "idx", "obj", "__privateMethod", "__privateSet", "secret", "error", "doDelete", "newPassword", "serializedDbString", "oldPassword", "responseString"]
}
